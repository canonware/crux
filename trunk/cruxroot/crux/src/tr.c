/* -*- mode: c ; c-file-style: "canonware-c-style" -*-
 ******************************************************************************
 *
 * <Copyright = jasone>
 * <License>
 *
 ******************************************************************************
 *
 * Version: Crux <Version = crux>
 *
 ******************************************************************************
 *
 * A cw_tr_t can be converted to a space-efficient representation of an unrooted
 * bifurcating phylogenetic tree.  The feasible duration of each iteration of
 * tabu search is bounded by the number of trees (and assoicated tabu lists)
 * that can be stored.  As such, the internal tree representation is as compact
 * as reasonably possible.
 *
 * Since tabu search depends on being able to determine if a tree has been
 * previously visited, tree comparison must be fast.  Therefore, a canonical
 * form is defined for trees.  Since the internal representation is effectively
 * a string, it can be used as the input to a string hashing function, which
 * makes searching for a specific tree among previously visited trees a constant
 * time operation.
 *
 * A tree is stored in parenthetical form, generated by doing an in-order
 * traversal, starting at the first taxon, and ordering subtrees (left vs right)
 * according to which subtree has the lowest-numbered taxon.  The leaf node to
 * taxon mapping is stored as an ordered list that corresponds to the order in
 * which leaves are visited during the aforementioned in-order traversal.  The
 * first taxon (effectively the root) is left out of the list, since its
 * position is always the same.
 *
 * The parentheses are represented as a string of bits, where 0 is `(', and 1 is
 * `)'.
 *
 * The taxon list can be thought of as a series of permutations, where element i
 *             / n - i \
 * represents: |       |.  As the number of choices decreases, so does the
 *             \   1   /
 * number of bits that are necessary to distinguish among the choices.
 *
 * Consider the following example tree:
 *
 *          E           B
 *           \         /
 *            \       /
 *             \     /
 *              \   /
 *               \ /
 *                V         G
 *                |         |
 *                |         |
 *                |         |
 *                |         |
 *                |         |
 *               / \        /---------D
 *              /   \      /
 *             /     \    /
 *            /       \  /
 *   A-------/         \/
 *           |         |
 *           |         |
 *           |         |
 *           |         |
 *           |         |
 *           C         F
 *
 * Assume the following ordering of taxa: A B C D E F G.  The above tree is
 * converted to canonical form by placing the lowest taxon (A) above the root
 * node, and re-ordering subtrees such that for every internal node, the left
 * subtree contains a lower taxon than any of the taxa in the right subtree.
 * Following is the canonical form of the above tree:
 *
 *             A
 *             |
 *             |
 *             |
 *            /^\
 *           /   \
 *          /     \
 *         /\      C
 *        /  \
 *       /    \
 *      /\     \
 *     /  \     \
 *    /    \     \
 *   B      E    /\
 *              /  \
 *             /    \
 *            /\     F
 *           /  \
 *          /    \
 *         D      G
 *
 * Doing an in-order traversal of the tree results in the following expression:
 *
 *   A(((BE)((DG)F))C)
 *
 * The topology for this tree can be represented by the following bit string:
 *
 *   ((()(())))
 *   -001001111
 *
 * The `-' character represents implicit information.
 *
 * The taxon visitation order can be represented by the following bit string
 * (keep in mind that only as many bits as are necessary are used for each
 * element):
 *
 *   A B   E  D  G F C
 *   - - 010 01 10 1 -
 *
 * The `-' characters represent implicit information (A always comes first, B
 * always comes second, and 1 choose 1 is always the same).
 *
 * Finally, padding bits are added to round the total number of bit up to a
 * multiple of 8, in order to work well on byte-addressable machinery.
 *
 * 
 *   001001111010011010000000
 *
 * In general, the number of bytes that are needed to store an n-taxon tree can
 * be calculated via the following formula:
 *
 *   __                                __
 *   |                 n-3              |
 *   |                ____  __       __ |
 *   |                \     |         | |
 *   | (2(n-3) + 1) +  >    |log (n-i)| |
 *   |                /___  |   2     | |
 *   |                 i=0              |
 *   | -------------------------------- |
 *   |                    8             |
 *   |                                  |
 *
 * The first term in the numerator corresponds to the parenthetical tree
 * expression, and the summation term corresponds to the taxa permutation.
 *
 * In summary, a tree is represented by a parenthetical expression, immediately
 * followed by the taxon visitation order permutation, and padded to the nearest
 * byte boundary.  The number of taxa in the tree is implied by the
 * parenthetical expression, and a well known taxon ordering is assumed.
 *
 ******************************************************************************
 *
 * cw_tr_t encapsulates an (optionally) unrooted bifurcating tree, and nodes are
 * represented by cw_trn_t.
 *
 ******************************************************************************
 *
 * cw_trn_t contains a time-efficient representation of a node of an
 * (optionally) unrooted bifurcating phlyogenetic tree.
 *
 ******************************************************************************/

#include "../include/modcrux.h"

/* Get bit a_i in a_vec (cw_uint8_t *). */
#define TR_STRING_BIT_GET(a_vec, a_i)					\
    (( ((a_vec)[(a_i) >> 3]) >> (7 - ((a_i) & 0x7)) ) & 0x1)

/* Set bit a_i in a_vec (cw_uint8_t *) to a_val (0 or 1). */
#define TR_STRING_BIT_SET(a_vec, a_i, a_val)				\
    (a_vec)[(a_i) >> 3] =						\
	((a_vec)[(a_i) >> 3] & (~(0x1 << (7 - ((a_i) & 0x7)))))		\
	| ((a_val) << ((7 - ((a_i) & 0x7))))

#ifdef CW_DBG
/* Validate an individual trn. */
static cw_bool_t
trn_p_validate(cw_trn_t *a_trn)
{
    cw_check_ptr(a_trn);
    cw_assert(a_trn->magic == CW_TRN_MAGIC);

    /* A trn must either be a leaf node, an internal node, or a root node.
     *
     * This check allows an internal node to have less than 3 neighbors, since
     * multiple calls are necessary to set up all the neighbor pointers.  This
     * also allows root nodes, which have two neighbors.
     *
     * A leaf node is not required to have a neighbor. */
    if (a_trn->taxon_num != CW_TRN_TAXON_NONE)
    {
	cw_uint32_t i, nneighbors;

	for (i = nneighbors = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
	{
	    if (a_trn->neighbors[i] != NULL)
	    {
		nneighbors++;
	    }
	}
	cw_assert(nneighbors <= 1);
    }

    return TRUE;
}
#endif

static void
trn_p_delete_recurse(cw_trn_t *a_trn)
{
    cw_uint32_t i;
    cw_trn_t *trn;

    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_trn->neighbors[i] != NULL)
	{
	    trn = a_trn->neighbors[i];
	    trn_detach(a_trn, trn);
	    trn_p_delete_recurse(trn);
	}
    }

    trn_delete(a_trn);
}

#ifdef CW_DBG
/* Return the number of taxa with number a_taxon_num in the subtree rooted at
 * a_trn. */
static cw_uint32_t
trn_p_validate_recurse(cw_trn_t *a_trn, cw_trn_t *a_prev,
		       cw_uint32_t a_taxon_num)
{
    cw_uint32_t retval;
    cw_uint32_t i;

    trn_p_validate(a_trn);

    if (a_trn->taxon_num != CW_TRN_TAXON_NONE)
    {
	/* Leaf node. */
	cw_assert(a_trn->neighbors[0] != NULL
		  || (a_trn->neighbors[1] == NULL
		      && a_trn->neighbors[1] == NULL));
	for (i = 1; i < CW_TRN_MAX_NEIGHBORS; i++)
	{
	    cw_assert(a_trn->neighbors[i] == NULL);
	}

	if (a_trn->taxon_num == a_taxon_num)
	{
	    retval = 1;
	}
	else
	{
	    retval = 0;
	}
    }
    else
    {
	/* Internal node. */
	for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
	{
	    cw_assert(a_trn->neighbors[i] != NULL);
	}

	retval = 0;
    }

    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_trn->neighbors[i] != NULL && a_trn->neighbors[i] != a_prev)
	{
	    retval += trn_p_validate_recurse(a_trn->neighbors[i],
					     a_trn, a_taxon_num);
	}
    }

    return retval;
}
#endif

#ifdef CW_DBG
/* Recursively traverse the tree and find the lowest numbered taxon. */
static cw_trn_t *
trn_p_root_get(cw_trn_t *a_trn, cw_trn_t *a_prev, cw_trn_t *a_root)
{
    cw_trn_t *retval, *root, *troot;
    cw_uint32_t i;

    if (a_trn->taxon_num != CW_TRN_TAXON_NONE
	&& (a_root == NULL || a_trn->taxon_num < a_root->taxon_num))
    {
	retval = a_trn;
	root = a_trn;
    }
    else
    {
	retval = NULL;
	root = a_root;
    }

    /* Iterate over neighbors. */
    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_trn->neighbors[i] != NULL && a_trn->neighbors[i] != a_prev)
	{
	    troot = trn_p_root_get(a_trn->neighbors[i], a_trn, root);
	    if (troot != NULL)
	    {
		retval = troot;
		root = troot;
	    }
	}
    }

    return retval;
}
#endif

/* Recursively traverse the tree and count the number of taxa. */
static cw_uint32_t
trn_p_ntaxa_get_recurse(cw_trn_t *a_trn, cw_trn_t *a_prev)
{
    cw_uint32_t retval;
    cw_uint32_t i;

    cw_dassert(trn_p_validate(a_trn));

    if (a_trn->taxon_num != CW_TRN_TAXON_NONE)
    {
	/* Leaf node. */
	retval = 1;
    }
    else
    {
	/* Internal node. */
	retval = 0;
    }

    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_trn->neighbors[i] != NULL && a_trn->neighbors[i] != a_prev)
	{
	    retval += trn_p_ntaxa_get_recurse(a_trn->neighbors[i], a_trn);
	}
    }

    return retval;
}

#ifdef CW_DBG
/* trn. */
static cw_uint32_t
trn_p_nedges_get(cw_trn_t *a_trn)
{
    cw_uint32_t retval, ntaxa;

    cw_dassert(trn_p_validate(a_trn));

    ntaxa = trn_p_ntaxa_get_recurse(a_trn, NULL);
    if (ntaxa > 1)
    {
	retval = (ntaxa * 2) - 3;
    }
    else
    {
	retval = 0;
    }

    return retval;
}
#endif

static cw_bool_t
trn_p_edge_get_recurse(cw_trn_t *a_trn, cw_uint32_t a_edge,
		       cw_trn_t *a_prev, cw_uint32_t *r_edge_count,
		       cw_trn_t **r_trn, cw_uint32_t *r_neighbor)
{
    cw_bool_t retval;
    cw_uint32_t i;

    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_trn->neighbors[i] != NULL && a_trn->neighbors[i] != a_prev)
	{
	    /* Increment edge count before recursing.  If the edge count has
	     * reached the desired value, return this trn and neighbor index,
	     * and terminate recursion. */
	    (*r_edge_count)++;
	    if (*r_edge_count > a_edge)
	    {
		cw_assert(*r_edge_count == a_edge + 1);
		*r_trn = a_trn;
		*r_neighbor = i;

		retval = TRUE;
		goto RETURN;
	    }

	    /* Recurse into neighbor subtrees. */
	    if (trn_p_edge_get_recurse(a_trn->neighbors[i], a_edge,
				       a_trn, r_edge_count,
				       r_trn, r_neighbor))
	    {
		retval = TRUE;
		goto RETURN;
	    }
	}
    }

    retval = FALSE;
    RETURN:
    return retval;
}

static cw_uint32_t
trn_p_edge_get(cw_trn_t *a_trn, cw_uint32_t a_edge, cw_trn_t **r_trn,
	       cw_uint32_t *r_neighbor)
{
    cw_uint32_t retval, edge_count = 0;

    trn_p_edge_get_recurse(a_trn, a_edge, NULL, &edge_count, r_trn, r_neighbor);

    return retval;
}

static cw_bool_t
trn_p_edge_index_get_recurse(cw_trn_t *a_trn, cw_trn_t *a_prev,
			     cw_trn_t *a_trn_a, cw_trn_t *a_trn_b,
			     cw_uint32_t *r_edge_count)
{
    cw_bool_t retval;
    cw_uint32_t i;

    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_trn->neighbors[i] != NULL && a_trn->neighbors[i] != a_prev)
	{
	    /* If this is the desired edge, terminate recursion.  Increment edge
	     * count before recursing. */
	    if ((a_trn == a_trn_a && a_trn->neighbors[i] == a_trn_b)
		|| (a_trn == a_trn_b && a_trn->neighbors[i] == a_trn_a))
	    {
		retval = TRUE;
		goto RETURN;
	    }
	    (*r_edge_count)++;

	    /* Recurse into neighbor subtree. */
	    if (trn_p_edge_index_get_recurse(a_trn->neighbors[i], a_trn,
					     a_trn_a, a_trn_b,
					     r_edge_count))
	    {
		retval = TRUE;
		goto RETURN;
	    }
	}
    }

    retval = FALSE;
    RETURN:
    return retval;
}

static cw_uint32_t
trn_p_edge_index_get(cw_trn_t *a_trn, cw_trn_t *a_trn_a, cw_trn_t *a_trn_b)
{
    cw_uint32_t retval = 0;

    trn_p_edge_index_get_recurse(a_trn, NULL, a_trn_a, a_trn_b, &retval);

    return retval;
}

/* Convert a tree to canonical form by re-ordering the neighbors array such that
 * subtrees are in increasing order of minimum taxon number contained. */
static cw_uint32_t
trn_p_canonize(cw_trn_t *a_trn, cw_trn_t *a_prev)
{
    cw_uint32_t retval;
    cw_uint32_t i, j, t;
    cw_uint32_t subtree_mins[CW_TRN_MAX_NEIGHBORS - 1];
    cw_uint32_t subtree_inds[CW_TRN_MAX_NEIGHBORS - 1];
    cw_bool_t swapped;

    cw_assert(a_prev != NULL
	      || trn_p_root_get(a_trn, NULL, NULL) == a_trn);

    if (a_trn->taxon_num != CW_TRN_TAXON_NONE)
    {
	/* Leaf node. */
	retval = a_trn->taxon_num;
    }
    else
    {
	/* Internal node. */
	retval = CW_TRN_TAXON_NONE;
    }

    /* Iteratively canonize subtrees, keeping track of the minimum taxon
     * number seen overall, as well as for each subtree. */
    for (i = j = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_trn->neighbors[i] != NULL && a_trn->neighbors[i] != a_prev)
	{
	    cw_assert(j < (CW_TRN_MAX_NEIGHBORS - 1));
	    subtree_mins[j] = trn_p_canonize(a_trn->neighbors[i], a_trn);
	    if (subtree_mins[j] < retval)
	    {
		retval = subtree_mins[j];
	    }
	    subtree_inds[j] = i;
	    j++;
	}
    }

    /* Bubble sort the subtrees.  This algorithm works in the general case, and
     * in the case this code is actually designed for (bifurcating trees), it
     * only requires a couple of extra branches. */
    do
    {
	swapped = FALSE;

	for (i = 0; i + 1 < j; i++)
	{
	    if (subtree_mins[i] > subtree_mins[i + 1])
	    {
		swapped = TRUE;

		/* Swap subtrees. */
		trn_neighbors_swap(a_trn, subtree_inds[i], subtree_inds[i + 1]);

		/* Swap subtree_* arrays. */
		t = subtree_mins[i];
		subtree_mins[i] = subtree_mins[i + 1];
		subtree_mins[i + 1] = t;
	    
		t = subtree_inds[i];
		subtree_inds[i] = subtree_inds[i + 1];
		subtree_inds[i + 1] = t;
	    }
	}
    } while (swapped);

    return retval;
}

static void
trn_p_bisect(cw_trn_t *a_trn, cw_uint32_t a_edge, cw_trn_t **r_trn_a,
	     cw_uint32_t *r_edge_a, cw_trn_t **r_trn_b,
	     cw_uint32_t *r_edge_b, cw_trn_t **r_spare_a,
	     cw_trn_t **r_spare_b)
{
    cw_trn_t *trn_a, *trn_b;
    cw_uint32_t edge;

    cw_assert(trn_p_root_get(a_trn, NULL, NULL) == a_trn);

    /* Get the nodes to either side of the edge where the bisection will be
     * done. */
    trn_p_edge_get(a_trn, a_edge, &trn_a, &edge);
    trn_b = trn_a->neighbors[edge];

    /* Detach the two nodes. */
    trn_detach(trn_a, trn_b);

    /* There are two cases possible for each of the nodes.  Each is either a
     * leaf node or an internal node.  For a leaf node, do nothing.  For an
     * internal node, join its neighbors together, and return the node as a
     * spare. */

    /* trn_a. */
    if (trn_a->taxon_num == CW_TRN_TAXON_NONE)
    {
	cw_trn_t *a, *b;
	cw_uint32_t i;

	/* Get trn_a's neighbors. */
	for (i = 0, a = b = NULL; b == NULL; i++)
	{
	    cw_assert(i < CW_TRN_MAX_NEIGHBORS);

	    if (trn_a->neighbors[i] != NULL)
	    {
		if (a == NULL)
		{
		    a = trn_a->neighbors[i];
		}
		else
		{
		    b = trn_a->neighbors[i];
		}
	    }
	}

	/* Detach. */
	trn_detach(trn_a, a);
	trn_detach(trn_a, b);

	/* Join. */
	trn_join(a, b);

	*r_trn_a = trn_p_root_get(a, NULL, NULL);
	trn_p_canonize(*r_trn_a, NULL);
	*r_edge_a = trn_p_edge_index_get(*r_trn_a, a, b);
	*r_spare_a = trn_a;
    }
    else
    {
	*r_trn_a = trn_a;
	*r_edge_a = CW_TRN_EDGE_NONE;
	*r_spare_a = NULL;
    }

    /* trn_b. */
    if (trn_b->taxon_num == CW_TRN_TAXON_NONE)
    {
	cw_trn_t *a, *b;
	cw_uint32_t i;

	/* Get trn_b's neighbors. */
	for (i = 0, a = b = NULL; b == NULL; i++)
	{
	    cw_assert(i < CW_TRN_MAX_NEIGHBORS);

	    if (trn_b->neighbors[i] != NULL)
	    {
		if (a == NULL)
		{
		    a = trn_b->neighbors[i];
		}
		else
		{
		    b = trn_b->neighbors[i];
		}
	    }
	}

	/* Detach. */
	trn_detach(trn_b, a);
	trn_detach(trn_b, b);

	/* Join. */
	trn_join(a, b);

	*r_trn_b = trn_p_root_get(a, NULL, NULL);
	trn_p_canonize(*r_trn_b, NULL);
	*r_edge_b = trn_p_edge_index_get(*r_trn_b, a, b);
	*r_spare_b = trn_b;
    }
    else
    {
	*r_trn_b = trn_b;
	*r_edge_b = CW_TRN_EDGE_NONE;
	*r_spare_b = NULL;
    }

    /* Move *r_spare_b to *r_spare_a if *r_spare_a is NULL. */
    if (*r_spare_a == NULL)
    {
	*r_spare_a = *r_spare_b;
	*r_spare_b = NULL;
    }
}

static void
trn_p_connect(cw_trn_t *a_trn_a, cw_uint32_t a_edge_a,
	      cw_trn_t *a_trn_b, cw_uint32_t a_edge_b,
	      cw_trn_t **ar_spare_a, cw_trn_t **ar_spare_b,
	      cw_trn_t **r_trn, cw_uint32_t *r_edge)
{
    cw_trn_t *trn_a, *trn_b;

    cw_assert(trn_p_root_get(a_trn_a, NULL, NULL) == a_trn_a);
    cw_dassert((a_edge_a == CW_TRN_EDGE_NONE
		&& trn_p_ntaxa_get_recurse(a_trn_a, NULL) == 1)
	       || (a_edge_a < trn_p_nedges_get(a_trn_a)));
    cw_assert(trn_p_root_get(a_trn_b, NULL, NULL) == a_trn_b);
    cw_dassert((a_edge_b == CW_TRN_EDGE_NONE
		&& trn_p_ntaxa_get_recurse(a_trn_b, NULL) == 1)
	       || (a_edge_b < trn_p_nedges_get(a_trn_b)));

    /* There are two cases possible for each subtree.  Each is either a single
     * leaf node, or a larger subtree.  For a leaf node, do nothing (recognize
     * this case by checking for an edge number of CW_TRN_EDGE_NONE).  For a
     * subtree, splice in one of the spares.  Then join the two subtrees. */

    if (a_edge_a != CW_TRN_EDGE_NONE)
    {
	cw_trn_t *a, *b;
	cw_uint32_t edge;

	cw_check_ptr(*ar_spare_a);
	trn_a = *ar_spare_a;
	*ar_spare_a = *ar_spare_b;
	*ar_spare_b = NULL;

	trn_p_edge_get(a_trn_a, a_edge_a, &a, &edge);
	b = a->neighbors[edge];

	/* Detach a and b. */
	trn_detach(a, b);

	/* Join a and b to trn_a. */
	trn_join(trn_a, a);
	trn_join(trn_a, b);
    }
    else
    {
	trn_a = a_trn_a;
    }

    if (a_edge_b != CW_TRN_EDGE_NONE)
    {
	cw_trn_t *a, *b;
	cw_uint32_t edge;

	cw_check_ptr(*ar_spare_a);
	trn_b = *ar_spare_a;
	*ar_spare_a = NULL;

	trn_p_edge_get(a_trn_b, a_edge_b, &a, &edge);
	b = a->neighbors[edge];

	/* Detach a and b. */
	trn_detach(a, b);

	/* Join a and b to trn_b. */
	trn_join(trn_b, a);
	trn_join(trn_b, b);
    }
    else
    {
	trn_b = a_trn_b;
    }

    /* Join trn_a and trn_b. */
    trn_join(trn_a, trn_b);

    /* Get the tree root, and canonize the tree. */
    if (a_trn_a->taxon_num < a_trn_b->taxon_num)
    {
	*r_trn = a_trn_a;
    }
    else
    {
	*r_trn = a_trn_b;
    }
    trn_p_canonize(*r_trn, NULL);

    /* Get the edge index for the connection. */
    *r_edge = trn_p_edge_index_get(*r_trn, trn_a, trn_b);
}

void
trn_new(cw_trn_t *a_trn)
{
    cw_check_ptr(a_trn);

    memset(a_trn, 0, sizeof(cw_trn_t));
    a_trn->taxon_num = CW_TRN_TAXON_NONE;

#ifdef CW_DBG
    a_trn->magic = CW_TRN_MAGIC;
#endif
}

void
trn_delete(cw_trn_t *a_trn)
{
    cw_dassert(trn_p_validate(a_trn));

#ifdef CW_DBG
    memset(a_trn, 0x5a, sizeof(cw_trn_t));
#endif
}

cw_uint32_t
trn_taxon_num_get(cw_trn_t *a_trn)
{
    cw_dassert(trn_p_validate(a_trn));

    return a_trn->taxon_num;
}

void
trn_taxon_num_set(cw_trn_t *a_trn, cw_uint32_t a_taxon_num)
{
    cw_dassert(trn_p_validate(a_trn));

    a_trn->taxon_num = a_taxon_num;
}

cw_trn_t *
trn_neighbor_get(cw_trn_t *a_trn, cw_uint32_t a_i)
{
    cw_dassert(trn_p_validate(a_trn));
    cw_assert(a_i < CW_TRN_MAX_NEIGHBORS);

    return a_trn->neighbors[a_i];
}

void
trn_neighbors_swap(cw_trn_t *a_trn, cw_uint32_t a_i, cw_uint32_t a_j)
{
    cw_trn_t *t_trn;

    cw_dassert(trn_p_validate(a_trn));
    cw_assert(a_i < CW_TRN_MAX_NEIGHBORS);
    cw_assert(a_j < CW_TRN_MAX_NEIGHBORS);
    cw_assert(a_i != a_j);

    t_trn = a_trn->neighbors[a_i];
    a_trn->neighbors[a_i] = a_trn->neighbors[a_j];
    a_trn->neighbors[a_j] = t_trn;
}

void
trn_join(cw_trn_t *a_a, cw_trn_t *a_b)
{
    cw_uint32_t i, j;

    cw_dassert(trn_p_validate(a_a));
    cw_dassert(trn_p_validate(a_b));
    cw_assert(a_a != a_b);
#ifdef CW_DBG
    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	cw_assert(a_a->neighbors[i] != a_b);
	cw_assert(a_b->neighbors[i] != a_a);
    }
#endif

    /* Find an empty slot in a_a. */
    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_a->neighbors[i] == NULL)
	{
	    break;
	}
    }
    cw_assert(i < CW_TRN_MAX_NEIGHBORS);

    /* Find an empty slot in a_b. */
    for (j = 0; j < CW_TRN_MAX_NEIGHBORS; j++)
    {
	if (a_b->neighbors[j] == NULL)
	{
	    break;
	}
    }
    cw_assert(j < CW_TRN_MAX_NEIGHBORS);

    /* Join the two nodes. */
    a_a->neighbors[i] = a_b;
    a_b->neighbors[j] = a_a;

    cw_dassert(trn_p_validate(a_a));
    cw_dassert(trn_p_validate(a_b));
}

void
trn_detach(cw_trn_t *a_a, cw_trn_t *a_b)
{
    cw_uint32_t i, j;

    cw_dassert(trn_p_validate(a_a));
    cw_dassert(trn_p_validate(a_b));

    /* Find the slot in a_a that points to a_b. */
    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_a->neighbors[i] == a_b)
	{
	    break;
	}
    }
    cw_assert(i < CW_TRN_MAX_NEIGHBORS);

    /* Find the slot in a_b that points to a_a. */
    for (j = 0; j < CW_TRN_MAX_NEIGHBORS; j++)
    {
	if (a_b->neighbors[j] == a_a)
	{
	    break;
	}
    }
    cw_assert(j < CW_TRN_MAX_NEIGHBORS);

    /* Detach the two nodes. */
    a_a->neighbors[i] = NULL;
    a_b->neighbors[j] = NULL;

    cw_dassert(trn_p_validate(a_a));
    cw_dassert(trn_p_validate(a_b));
}

void *
trn_aux_get(cw_trn_t *a_trn)
{
    cw_dassert(trn_p_validate(a_trn));

    return a_trn->aux;
}

void
trn_aux_set(cw_trn_t *a_trn, void *a_aux)
{
    cw_dassert(trn_p_validate(a_trn));

    a_trn->aux = a_aux;
}

/* tr. */
#ifdef CW_DBG
/* Validate a tree constructed with trn's. */
static cw_bool_t
tr_p_validate(cw_tr_t *a_tr, cw_bool_t a_validate_contiguous)
{
    cw_uint32_t i, j, n;

    cw_check_ptr(a_tr);
    cw_assert(a_tr->magic == CW_TR_MAGIC);
    cw_assert(trn_p_root_get(a_tr->croot, NULL, NULL) == a_tr->croot);
    cw_assert(a_tr->ntaxa == trn_p_ntaxa_get_recurse(a_tr->croot, NULL));
    cw_assert((a_tr->rooted == FALSE
	       && a_tr->nedges == trn_p_nedges_get(a_tr->croot) - 1)
	      || a_tr->nedges == trn_p_nedges_get(a_tr->croot));

    /* Traverse the tree, and make sure that the following invariants hold:
     *
     * + Leaf nodes have a taxon number and precisely 1 neighbor.
     *
     * + Internal nodes have no taxon number and precisely 3 neighbors.
     *
     * + The root node (if there is one) has precisely 2 neighbors and no taxon
     *   number.
     *
     * + Each taxon number appears no more than once in the tree.
     *
     * These invariants allow gaps in the taxon numbering, which has the
     * potential to cause problems (not in the tr implementation but elswhere),
     * but requiring contiguous taxon numbering would make validating tree
     * bisections impossible.  Therefore, contiguous taxon numbering is only
     * optionally validated. */
    if (a_tr->rooted)
    {
	cw_trn_t *left, *right;

	/* Rooted tree. */

	/* Get left and right subtrees. */
	for (i = 0, left = right = NULL; i < CW_TRN_MAX_NEIGHBORS; i++)
	{
	    if (a_tr->root->neighbors[i] != NULL)
	    {
		if (left == NULL)
		{
		    left = a_tr->root->neighbors[i];
		}
		else
		{
		    right = a_tr->root->neighbors[i];
		    break;
		}
	    }
	}

	for (i = j = 0; j < a_tr->ntaxa; i++, j += n)
	{
	    n = trn_p_validate_recurse(left, a_tr->root, i);
	    n += trn_p_validate_recurse(right, a_tr->root, i);
	    cw_assert(n <= 1);
	}
    }
    else
    {
	/* Unrooted tree. */
	for (i = j = 0; j < a_tr->ntaxa; i++, j += n)
	{
	    n = trn_p_validate_recurse(a_tr->croot, NULL, i);
	    cw_assert(n <= 1);
	}
    }

    if (a_validate_contiguous)
    {
	cw_assert(i == a_tr->ntaxa);
    }

    return TRUE;
}
#endif

static void
tr_p_tbr(cw_tr_t *a_tr, cw_uint32_t a_bisect, cw_uint32_t a_reconnect_a,
	 cw_uint32_t a_reconnect_b, cw_uint32_t *r_bisect,
	 cw_uint32_t *r_reconnect_a, cw_uint32_t *r_reconnect_b)
{
    cw_trn_t *trn, *trn_a, *trn_b, *spare_a, *spare_b;

    /* Bisect. */
    cw_assert(a_bisect < trn_p_nedges_get(a_tr->croot));
    trn_p_bisect(a_tr->croot, a_bisect,
		 &trn_a, r_reconnect_a,
		 &trn_b, r_reconnect_b,
		 &spare_a, &spare_b);

    /* Reconnect. */
    cw_assert(a_reconnect_a < trn_p_nedges_get(trn_a));
    cw_assert(a_reconnect_b < trn_p_nedges_get(trn_b));
    trn_p_connect(trn_a, a_reconnect_a,
		  trn_b, a_reconnect_b,
		  &spare_a, &spare_b,
		  &trn, r_bisect);
    cw_assert(trn == a_tr->croot);

    cw_dassert(tr_p_validate(a_tr, TRUE));
}

static void
trn_p_bisection_edge_get_recurse(cw_trn_t *a_trn, cw_trn_t *a_other,
				 cw_trn_t *a_prev, cw_uint32_t *r_edge_count,
				 cw_uint32_t *r_bisection_edge)
{
    cw_uint32_t i, prev_edge_count;

    /* Save the previous edge count, in case it ends up being the index of the
     * edge adjacent to the bisection. */
    prev_edge_count = *r_edge_count;

    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_trn->neighbors[i] != NULL
	    && a_trn->neighbors[i] != a_prev
	    && a_trn->neighbors[i] != a_other)
	{
	    /* Increment edge count before recursing. */
	    (*r_edge_count)++;

	    /* Recurse into neighbor subtrees. */
	    trn_p_bisection_edge_get_recurse(a_trn->neighbors[i], a_other,
					     a_trn, r_edge_count,
					     r_bisection_edge);
	}
	else if (a_trn->neighbors[i] == a_other)
	{
	    /* Store the index of the edge adjacent to the bisection. */
	    *r_bisection_edge = prev_edge_count;
	}
    }
}

static void
trn_p_bisection_edges_get(cw_trn_t *a_trn, cw_uint32_t a_edge, cw_trt_t *r_trt)
{
    cw_uint32_t edge_count, neighbor;
    cw_trn_t *trn, *adj_a, *adj_b;

    /* Count the number of edges that would be in each half of the tree, were it
     * bisected.  Also, determine which edges of the subtrees would be used to
     * reverse the bisection. */

    /* Get the trn's adjacent to the bisection edge. */
    edge_count = 0;
    trn_p_edge_get_recurse(a_trn, a_edge, NULL, &edge_count, &adj_a, &neighbor);
    adj_b = adj_a->neighbors[neighbor];

    /* Get the number of edges in the first half of the bisection, as well as
     * the index of the edge adjacent to the bisection. */
    r_trt->nedges_a = 0;
    trn_p_bisection_edge_get_recurse(a_trn, adj_b, NULL, &r_trt->nedges_a,
				     &r_trt->self_a);

    /* Get the lowest numbered taxon in the second half of the bisection. */
    trn = trn_p_root_get(adj_b, NULL, NULL);

    /* Get the number of edges in the second half of the bisection, as well as
     * the index of the edge adjacent to the bisection. */
    r_trt->nedges_b = 0;
    trn_p_bisection_edge_get_recurse(trn, adj_a, NULL, &r_trt->nedges_b,
				     &r_trt->self_b);
}

static void
tr_p_tbr_trt_init(cw_tr_t *a_tr)
{
    cw_uint32_t i, offset, a, b;
    cw_bool_t init = FALSE;

    if (a_tr->trt == NULL)
    {
	/* Build table to make neighbor iteration fast. */
	if (a_tr->nedges > 0)
	{
	    a_tr->trt = (cw_trt_t *) nxa_malloc(sizeof(cw_trt_t)
						* (a_tr->nedges + 1));
	}
	init = TRUE;
    }
    if (a_tr->tbr_undoable)
    {
	/* Rebuild table to make neighbor iteration fast. */
	a_tr->tbr_undoable = FALSE;
	init = TRUE;
    }

    if (init)
    {
	for (i = offset = 0; i < a_tr->nedges; i++)
	{
	    /* Record offset. */
	    a_tr->trt[i].offset = offset;

	    /* Record number of subtree edges. */
	    a_tr->trt[i].nedges_a = 0;
	    a_tr->trt[i].nedges_b = 0;

	    /* Set trt[i].{nedges,self}_[ab]. */
	    trn_p_bisection_edges_get(a_tr->croot, i, &a_tr->trt[i]);

	    /* Update offset. */
	    if (a_tr->trt[i].nedges_a != 0)
	    {
		a = a_tr->trt[i].nedges_a;
	    }
	    else
	    {
		a = 1;
	    }

	    if (a_tr->trt[i].nedges_a != 0)
	    {
		a = a_tr->trt[i].nedges_a;
	    }
	    else
	    {
		a = 1;
	    }

	    offset += (a * b) - 1;
	}
    }
}

static int
tr_p_trt_compare(const void *a_key, const void *a_val)
{
    int retval;
    const cw_trt_t *key = (const cw_trt_t *) a_key;
    const cw_trt_t *val = (const cw_trt_t *) a_val;

    if (key->offset < val->offset)
    {
	retval = -1;
    }
    else if (key->offset < (&val[1])->offset)
    {
	retval = 0;
    }
    else
    {
	retval = 1;
    }

    return retval;
}

/*           __         __
 *           |           |
 * Calculate |log (a_val)|.  This is accomplished by counting the number of bits
 *           |   2       |
 * set to 1 while iterating to find the most significant bit set.  If there
 * was more than one 1 bit, the result is incremented (ceiling).
 *
 * Note that the result for a_val == 1 should be 1, but this function would
 * return 0.  However, we never care about that case in this code, so it doesn't
 * matter.
 */
static cw_uint32_t
tr_p_string_log2ceil(cw_uint32_t a_val)
{
    cw_uint32_t retval;
    cw_uint32_t ones;

    cw_assert(a_val > 1);

    /* Find the most significant 1 bit. */
    for (retval = ones = 0; a_val != 0; retval++, a_val >>= 1)
    {
	ones += (a_val & 0x1);
    }

    /* Decrement unless ceiling needs to be taken. */
    if (ones == 1)
    {
	retval--;
    }

    return retval;
}

/* Calculatet bit vector bit count, given the number of taxa in the tree. */
static cw_uint32_t
tr_p_string_ntaxa2nbits(cw_uint32_t a_ntaxa)
{
    cw_uint32_t retval;
    cw_uint32_t i;

    /* Use the numerator of the formula at the beginning of this file to
     * calculate the number of bits required to store a tree with a_ntaxa. */

    /* First term of numerator (parenthetical tree). */
    retval = 2 * (a_ntaxa - 3) + 1;

    /* Second term of numerator (summation, taxa permutation). */
    for (i = 0; i < a_ntaxa - 2; i++)
    {
	retval += tr_p_string_log2ceil(a_ntaxa - i);
    }

    return retval;
}

/* Calculate bit vector byte count, using the bit representation of the encoded
 * tree. */
static cw_uint32_t
tr_p_string_sizeof(const cw_uint8_t *a_string)
{
    return tr_string_ntaxa2sizeof(tr_string_ntaxa(a_string));
}

/* Comparison function passed to bsearch(3) when searching for a taxon to build
 * a taxa permutation. */
static int
tr_p_string_taxon_num_compar(const void *a_a, const void *a_b)
{
    int retval;
    cw_uint32_t *a = (cw_uint32_t *) a_a;
    cw_uint32_t *b = (cw_uint32_t *) a_b;

    if (*a < *b)
    {
	retval = -1;
    }
    else if (*a > *b)
    {
	retval = 1;
    }
    else
    {
	retval = 0;
    }

    return retval;
}

#ifdef CW_DBG
static cw_bool_t
tr_p_string_validate(const cw_uint8_t *a_string)
{
    cw_uint32_t ntaxa, nbytes, nbits;
    cw_uint32_t i, j, bitind, npbits, pbits;

    cw_check_ptr(a_string);

    ntaxa = tr_string_ntaxa(a_string);
    nbytes = tr_string_ntaxa2sizeof(ntaxa);
    nbits = tr_p_string_ntaxa2nbits(ntaxa);

    /* Assert that trailing bits are all 0. */
    cw_assert((a_string[nbytes - 1] & (0xff >> (nbits & 0x7))) == 0);

    /* Assert that no invalid choices exist in the taxon permutation.  The taxa
     * permutation is stored in a format that makes it impossible to encode the
     * same taxon number twice.  However, there can still be invalid numbers in
     * the encoding (for example 7 cannot be used for a 5 choose 1 choice). */
    for (i = ntaxa - 2, bitind = 2 * (ntaxa - 3) + 1;
	 i > 1;
	 i--)
    {
	for (j = 0, npbits = tr_p_string_log2ceil(i), pbits = 0;
	     j < npbits;
	     j++, bitind++)
	{
	    pbits <<= 1;
	    pbits |= TR_STRING_BIT_GET(a_string, bitind);

	    cw_assert(pbits < i);
	}
    }

    return TRUE;
}
#endif

static void
tr_p_string_new_recurse(cw_uint8_t *a_string, cw_uint32_t *a_bitind_paren,
			cw_uint32_t *a_bitind_perm, cw_trn_t *a_trn, cw_trn_t *a_prev,
			cw_uint32_t *a_unchosen, cw_uint32_t *a_nunchosen)
{
    cw_uint32_t i;

    if (a_trn->taxon_num != CW_TRN_TAXON_NONE)
    {
	if (*a_nunchosen > 1)
	{
	    cw_uint32_t *taxon, offset, nbits;

	    /* Leaf node. */

	    /* Avoid encoding taxon 1, since it is implicit. */
	    if (a_trn->taxon_num != 1)
	    {
		/* Get the offset of this taxon within the array of unchosen
		 * taxa. */
		taxon = (cw_uint32_t *) bsearch(&a_trn->taxon_num,
						a_unchosen, *a_nunchosen,
						sizeof(cw_uint32_t),
						tr_p_string_taxon_num_compar);
		cw_check_ptr(taxon);
		offset = (cw_uint32_t) (taxon - a_unchosen);

		/* Determine how many bits to use in storing this choice. */
		nbits = tr_p_string_log2ceil(*a_nunchosen);

		/* Remove the taxon from the array of unchosen taxa. */
		if (offset < *a_nunchosen - 1)
		{
		    memmove(&a_unchosen[offset], &a_unchosen[offset + 1],
			    (*a_nunchosen - offset - 1) * sizeof(cw_uint32_t));
		}
		(*a_nunchosen)--;

		/* Store this choice. */
		for (i = 0; i < nbits; i++)
		{
		    TR_STRING_BIT_SET(a_string, *a_bitind_perm,
				      ((offset >> (nbits - i - 1) & 0x1)));
//		    fprintf(stderr, "%c",
//			    ((offset >> (nbits - i - 1) & 0x1)) ? '1' : '0');
		    (*a_bitind_perm)++;
		}
//		fprintf(stderr, " ");
	    }
	}
    }
    else
    {
	cw_bool_t did_paren = FALSE;

	/* Internal node. */

	for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
	{
	    if (a_trn->neighbors[i] != NULL && a_trn->neighbors[i] != a_prev)
	    {
		if (did_paren == FALSE)
		{
		    did_paren = TRUE;

		    /* Insert open paren. */
		    TR_STRING_BIT_SET(a_string, *a_bitind_paren, 0);
		    (*a_bitind_paren)++;
//		    fprintf(stderr, "(");
		}

		/* Recurse. */
		tr_p_string_new_recurse(a_string, a_bitind_paren, a_bitind_perm,
					a_trn->neighbors[i], a_trn,
					a_unchosen, a_nunchosen);
	    }
	}

	if (did_paren)
	{
	    /* Insert close paren. */
	    TR_STRING_BIT_SET(a_string, *a_bitind_paren, 1);
	    (*a_bitind_paren)++;
//	    fprintf(stderr, ")");
	}
    }
}

void
tr_new(cw_tr_t *a_tr, cw_trn_t *a_trn)
{
    cw_check_ptr(a_tr);
    cw_dassert(trn_p_validate(a_trn));

    memset(a_tr, 0, sizeof(cw_tr_t));

#ifdef CW_DBG
    {
	cw_uint32_t i, nneighbors;

	/* Make sure this is a rooted tree. */
	for (i = nneighbors = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
	{
	    if (a_trn->neighbors[i] != NULL)
	    {
		nneighbors++;
	    }
	}
	cw_assert(nneighbors == 2);
	cw_assert(a_trn->taxon_num == CW_TRN_TAXON_NONE);
    }
#endif
    a_tr->rooted = TRUE;
    a_tr->root = a_trn;

    a_tr->croot = trn_p_root_get(a_trn, NULL, NULL);

    a_tr->ntaxa = trn_p_ntaxa_get_recurse(a_trn, NULL);

    if (a_tr->ntaxa > 1)
    {
	a_tr->nedges = (a_tr->ntaxa * 2) - 3;
    }
    else
    {
	a_tr->nedges = 0;
    }

#ifdef CW_DBG
    a_tr->magic = CW_TR_MAGIC;
#endif
}

void
tr_delete(cw_tr_t *a_tr, cw_bool_t a_delete_trns)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    if (a_delete_trns)
    {
	if (a_tr->rooted == FALSE)
	{
	    trn_delete(a_tr->root);
	}

	trn_p_delete_recurse(a_tr->croot);
    }

    if (a_tr->trt != NULL)
    {
	nxa_free(a_tr->trt, sizeof(cw_trt_t) * (a_tr->nedges + 1));
    }

#ifdef CW_DBG
    memset(a_tr, 0x5a, sizeof(cw_tr_t));
#endif
}

cw_uint32_t
tr_ntaxa_get(cw_tr_t *a_tr)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    return a_tr->ntaxa;
}

cw_uint32_t
tr_nedges_get(cw_tr_t *a_tr)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    return a_tr->nedges;
}

/* Do an in-order traversal of the tree and return the node that neighbors the
 * edge being sought, along with which neighbor of that node the edge is
 * between. */
void
tr_edge_get(cw_tr_t *a_tr, cw_uint32_t a_edge, cw_trn_t **r_trn,
	    cw_uint32_t *r_neighbor)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    if (a_edge != CW_TRN_EDGE_NONE)
    {
	cw_uint32_t edge_count = 0;
#ifdef CW_DBG
	cw_bool_t found;
#endif

	cw_assert(a_tr->rooted == FALSE);
	cw_assert(trn_p_ntaxa_get_recurse(a_tr->croot, NULL) > 1);

#ifdef CW_DBG
	found =
#endif
	    trn_p_edge_get_recurse(a_tr->croot, a_edge, NULL, &edge_count,
				   r_trn, r_neighbor);
	cw_dassert(found);
    }
}

cw_uint32_t
tr_edge_index_get(cw_tr_t *a_tr, cw_trn_t *a_trn_a, cw_trn_t *a_trn_b)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    return trn_p_edge_index_get(a_tr->croot, a_trn_a, a_trn_b);
}

cw_trn_t *
tr_croot_get(cw_tr_t *a_tr)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    return a_tr->croot;
}

cw_trn_t *
tr_root_get(cw_tr_t *a_tr)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    return a_tr->root;
}

cw_bool_t
tr_rooted(cw_tr_t *a_tr)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    return a_tr->rooted;
}

void
tr_root(cw_tr_t *a_tr, cw_trn_t *a_trn_a, cw_trn_t *a_trn_b)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));
    cw_assert(a_tr->rooted == FALSE);

    trn_detach(a_trn_a, a_trn_b);
    trn_join(a_tr->root, a_trn_a);
    trn_join(a_tr->root, a_trn_b);

    a_tr->rooted = TRUE;
}

void
tr_unroot(cw_tr_t *a_tr)
{
    cw_uint32_t i;
    cw_trn_t *trn_a, *trn_b;

    cw_dassert(tr_p_validate(a_tr, TRUE));
    cw_assert(a_tr->rooted);

    trn_a = NULL;
    trn_b = NULL;
    for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
    {
	if (a_tr->root->neighbors[i] != NULL)
	{
	    if (trn_a == NULL)
	    {
		trn_a = a_tr->root->neighbors[i];
	    }
	    else
	    {
		trn_b = a_tr->root->neighbors[i];
		break;
	    }
	}
    }
    cw_check_ptr(trn_a);
    cw_check_ptr(trn_b);

    trn_detach(a_tr->root, trn_a);
    trn_detach(a_tr->root, trn_b);
    trn_join(trn_a, trn_b);

    a_tr->rooted = FALSE;
}

void
tr_canonize(cw_tr_t *a_tr)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));
    cw_assert(trn_p_root_get(a_tr->croot, NULL, NULL) == a_tr->croot);

    trn_p_canonize(a_tr->croot, NULL);
}

void
tr_tbr(cw_tr_t *a_tr, cw_uint32_t a_bisect, cw_uint32_t a_reconnect_a,
       cw_uint32_t a_reconnect_b, cw_uint32_t *r_bisect,
       cw_uint32_t *r_reconnect_a, cw_uint32_t *r_reconnect_b)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    /* Perform TBR. */
    tr_p_tbr(a_tr, a_bisect, a_reconnect_a, a_reconnect_b, r_bisect,
	     r_reconnect_a, r_reconnect_b);

    /* Record undo information. */
    a_tr->tbr_undoable = TRUE;
    a_tr->tbr_undo_bisect = *r_bisect;
    a_tr->tbr_undo_reconnect_a = *r_reconnect_a;
    a_tr->tbr_undo_reconnect_b = *r_reconnect_b;
}

void
tr_tbr_undo(cw_tr_t *a_tr)
{
    cw_uint32_t bisect, reconnect_a, reconnect_b;

    cw_dassert(tr_p_validate(a_tr, TRUE));
    cw_assert(a_tr->tbr_undoable);

    /* Perform TBR. */
    tr_p_tbr(a_tr, a_tr->tbr_undo_bisect, a_tr->tbr_undo_reconnect_a,
	     a_tr->tbr_undo_reconnect_b, &bisect, &reconnect_a, &reconnect_b);

    /* Clear undoable flag. */
    a_tr->tbr_undoable = FALSE;
}

cw_uint32_t
tr_tbr_nneighbors_get(cw_tr_t *a_tr)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    tr_p_tbr_trt_init(a_tr);

    return a_tr->trt[a_tr->nedges].offset;
}

void
tr_tbr_neighbor_get(cw_tr_t *a_tr, cw_uint32_t a_neighbor,
		    cw_uint32_t *r_bisect, cw_uint32_t *r_reconnect_a,
		    cw_uint32_t *r_reconnect_b)
{
    cw_trt_t key, *trt;
    cw_uint32_t rem, a, b;

    cw_dassert(tr_p_validate(a_tr, TRUE));

    tr_p_tbr_trt_init(a_tr);

    /* Get the bisection edge. */
    key.offset = a_neighbor;
    trt = bsearch(&key, a_tr->trt, a_tr->nedges, sizeof(cw_trt_t),
		  tr_p_trt_compare);
    cw_check_ptr(trt);

    /* Get the reconnection edges.  If the reconnection edges happen to be those
     * that would reverse the bisection, instead return the last possible
     * reconnection combination for this bisection.  This results in a rather
     * strange ordering for the enumeration, but is always correct. */
    rem = a_neighbor - trt->offset;

    if (trt->nedges_a > 0)
    {
	a = rem / trt->nedges_b;
	if (trt->nedges_b > 0)
	{
	    b = rem % trt->nedges_b;
	}
	else
	{
	    b = 0;
	}
    }
    else
    {
	a = 0;
	b = rem;
    }

    if (a == trt->self_a && b == trt->self_b)
    {
	/* Avoid undoing the bisection. */
	if (trt->nedges_a > 1)
	{
	    a = trt->nedges_a - 1;
	}
	else
	{
	    a = 0;
	}

	if (trt->nedges_b > 1)
	{
	    b = trt->nedges_b - 1;
	}
	else
	{
	    b = 0;
	}
    }
    *r_reconnect_a = a;
    *r_reconnect_b = b;
}

void
tr_string(cw_tr_t *a_tr, cw_uint8_t *ar_string, cw_uint32_t a_len)
{
    cw_trn_t *node;
    cw_uint32_t bitind_paren, bitind_perm, i, *unchosen, nunchosen;

    cw_dassert(tr_p_validate(a_tr, TRUE));
    cw_assert(tr_rooted(a_tr) == FALSE);
    cw_assert(a_len == tr_string_ntaxa2sizeof(a_tr->ntaxa));

    /* Set the last byte to 0 to assure that there is no trailing garbage. */
    ar_string[a_len - 1] = 0;

    /* Canonize the tree. */
    trn_p_canonize(a_tr->croot, NULL);

    /* The tree can now be converted to parenthetical form and taxa permutation
     * using an in-order traversal. */
    bitind_paren = 0;
    bitind_perm = 2 * (a_tr->ntaxa - 3) + 1;

    /* The first open paren is implied. */

    /* Create a taxon permutation from a_tr->croot.  This requires maintaining a
     * list of the taxa that remain to be chosen from.  An array of taxon
     * numbers is maintained in compact form (already chosen taxa are removed,
     * and trailing space in the array is ignored).
     *
     * Use generic allocation here rather than nxa, since this is transient
     * allocation that lasts only for the duration of this function. */
    unchosen = (cw_uint32_t *) cw_malloc((a_tr->ntaxa - 2)
					 * sizeof(cw_uint32_t));
    for (i = 0; i < (a_tr->ntaxa - 2); i++)
    {
	unchosen[i] = i + 2;
    }
    nunchosen = a_tr->ntaxa - 2;

    /* Recurse if the tree has an internal node.  Taxon 0 must be avoided
     * during the traversal, since it is implicit in the canonical tree
     * encoding.  Additionally, the first internal node must be handled here
     * rather than simply recursing to it, since the first '(' is implied. */
    node = a_tr->croot->neighbors[0];
    if (node != NULL && node->taxon_num == CW_TRN_TAXON_NONE)
    {
	for (i = 0; i < CW_TRN_MAX_NEIGHBORS; i++)
	{
	    if (node->neighbors[i] != NULL
		&& node->neighbors[i] != a_tr->croot)
	    {
		/* Recurse. */
		tr_p_string_new_recurse(ar_string, &bitind_paren, &bitind_perm,
					node->neighbors[i], node,
					unchosen, &nunchosen);
	    }
	}
    }

    /* Insert close paren. */
    TR_STRING_BIT_SET(ar_string, bitind_paren, 1);
//    fprintf(stderr, ")\n");
    cw_assert(bitind_paren == 2 * (a_tr->ntaxa - 3));

    /* Clean up. */
    cw_free(unchosen);
}

/* Determine the number of taxa in a_string. */
cw_uint32_t
tr_string_ntaxa(const cw_uint8_t *a_string)
{
    cw_uint32_t retval;
    cw_uint32_t i, npairs, curdepth;

    /* Determine how many pairs of parentheses there are in the bit vector. */
    for (i = 0, npairs = curdepth = 1; curdepth > 0; i++)
    {
	if (TR_STRING_BIT_GET(a_string, i))
	{
	    curdepth--;
	}
	else
	{
	    npairs++;
	    curdepth++;
	}
    }

    /* Using the first term of the formula at the top of the file, we know that:
     *
     *   nparens == 2(n-3) + 1
     *
     *   npairs == (nparens + 1) / 2
     *
     *   npairs == ((2(n-3) + 1) + 1) / 2
     *
     *   npairs == (2(n-3) + 2) / 2
     *
     *   npairs == (2(n-2)) / 2
     *
     *   npairs == n - 2
     *
     *   n == npairs + 2
     *
     * Solve for n (retval). */
    retval = npairs + 2;

    return retval;
}

/* Calculate bit vector byte count, given the number of taxa in the tree. */
cw_uint32_t
tr_string_ntaxa2sizeof(cw_uint32_t a_ntaxa)
{
    cw_uint32_t retval;
    cw_uint32_t ceil;

    /* Use the formula at the beginning of this file to calculate the number of
     * bytes required to store a tree with a_ntaxa. */

    retval = tr_p_string_ntaxa2nbits(a_ntaxa);

    /* Ceiling of denominator division. */
    ceil = !!(retval & 0x7);

    /* Divide. */
    retval >>= 3;
    retval += ceil;

    return retval;
}

cw_uint32_t
tr_string_hash(const void *a_key)
{
    cw_uint32_t retval;
    const cw_uint8_t *string;
    cw_uint32_t len, i;

    cw_check_ptr(a_key);

    string = (const cw_uint8_t *) a_key;;
    cw_dassert(tr_p_string_validate(string));

    len = tr_p_string_sizeof(string);
    for (i = retval = 0; i < len; i++)
    {
	retval = retval * 33 + string[i];
    }

    return retval;
}

cw_bool_t
tr_string_key_comp(const void *a_k1, const void *a_k2)
{
    cw_bool_t retval;
    const cw_uint8_t *string1, *string2;
    cw_uint32_t len1, len2;

    cw_check_ptr(a_k1);
    cw_check_ptr(a_k2);

    string1 = (const cw_uint8_t *) a_k1;
    string2 = (const cw_uint8_t *) a_k2;
    cw_dassert(tr_p_string_validate(string1));
    cw_dassert(tr_p_string_validate(string2));

    len1 = tr_p_string_sizeof(string1);
    len2 = tr_p_string_sizeof(string2);
    if (len1 != len2)
    {
	retval = FALSE;
    }
    else
    {
	retval = memcmp(string1, string2, len1) ? FALSE : TRUE;
    }

    return retval;
}

void *
tr_aux_get(cw_tr_t *a_tr)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    return a_tr->aux;
}

void
tr_aux_set(cw_tr_t *a_tr, void *a_aux)
{
    cw_dassert(tr_p_validate(a_tr, TRUE));

    a_tr->aux = a_aux;
}
