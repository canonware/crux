* Fix distance matrix parser to deal with a last line that is missing a newline.

* Rewrite Newick parser in C.

* Try to change the random NJ code to avoid having to look at columns when
  deciding on row pairs.

* Gracefully raise an exception (or just complain and keep going?) when parsing
  Newick files that have extra parens (as do ROSE outputs).

  The NewickParser code shouldn't ever allow this to happen; the grammar that is
  enforced should require multiple objects inside parens.

* Figure out how to use command line parsing module on crux.opts, and write some
  canned scripts for inclusion in crux releases.

  Save sys.argv, redefine sys.argv, call option parser, restore sys.argv.

* Do not bother calculating bit vectors for leaf edges in the RF distance
  calculation code.

* Add programmatic tree validation, so that it's possible to detect and recover
  from malformed trees.  Right now, the tree validation code is only useful for
  Crux debugging.

================================================================================

* Use CTMatrix for MP.

* Add basic MP and TBR tests.

* Add true tree holding, rather than just the limited form of holding that the
  tr code supports.

* Convert C comments to // style.

* Collapse rendering code into single code paths, which are passed a callback
  method (or something like that).  The current setup requires testing both
  file and string rendering, and is a pain to update.

================================================================================

* Move TBR code out of CxTr.c, into CxTreeTbr.c.  This will remove some scary
  constraints on how nodes/edges are rearranged (constraints imposed by the MP
  code).

* Move canonization code to CxTreeCanonize.c.

* Move MP code from CxTr.c to CxTreeMp.c.

* Move tree holding code out of CxTr.c.  It belongs with the MP code (in
  CxTreeMp.c).

* Get rid of CxTr.c entirely.  Move functionality to either be merged with the
  Python glue, or into separate files.

================================================================================

* Implement Lewis crossover (in CxTreeCrossover.c).

  + Try iterative hill climbing, where iteration is repeated crossovers between
    the current best tree and another one in hand.

  + Try a hybrid of crossover and TBR hill climbing iteration.  This looks
    promising, unless the hill climbing takes too much time.

  + Try a GA, where crossover is Lewis crossover, and mutation is TBR
    transformation.  I don't have a good feeling for how well this will work.  A
    steady-state population is probably necessary to avoid thrashing around in
    suboptimal tree space.

================================================================================

* Collapse unsupported (zero-change) branches when storing trees, in order to
  avoid storing equivalent trees.

* Write tree comparison code that deals with collapsed trees (CxTreeEqual.c)

================================================================================

* Implement Sankoff parsimony, in preparation for supporting protein parsimony.

* Generalize character types to handle protein, as well as arbitrary characters.

* Add code for calculating pairwise distances.  Consider making it MPI-aware
  (Jack seemed to think this would be useful.)

================================================================================

Implement MSA.  Consider making this general enough to allow heuristic
simultaneous alignment of an arbitrary number of sequences.

================================================================================

* Do bisection/MP during tree recursion.

* Terminate scoring early if identical on a per-word basis.

================================================================================

* Implement other heuristic tree constructors, such as sequential addition,
  UPGMA, star decomposition, etc.

* Make it possible to permanently discard uninformative characters?  In any
  case, uninformative character elimination is rather opaque at the moment, and
  more information needs to be made available.

* Either come up with a simple command line syntax (sorta like PAUP's), or
  provide a number of crux scripts that provide similar ease of use for typical
  operations.

* Add interactive help.

* Create rpm for crux.

* Add documentation infrastructure, as well as full documentation of APIs.

=== Sometime ===

* Implement crux.Tree.Tree.dup().

* Make it possible to allow cyclic graphs (currently constrained to acyclic
  graphs).

* Implement NNI and SPR.  These should be easy, since they are subsets of TBR.

* Implement client-server job processing and comprehensive checkpointing
  capabilities.  This will deal with the unreliability of the cluster, and make
  it possible for all nodes to work cooperatively.

  Use something like OPIE for authentication?  It's absolutely essential to do
  something, since oceanus is exposed to the net.  It may be effective to simply
  bind to the internal network interface, but this is a rather hokey solution.

* Add a GUI.  GUI features:

  + Load/store:
    - NEXUS files.
    - Newick tree files.
    - Phylip distance matrices.
    - FASTA files.
    - Scripts (Python)

  + Manipulate (create, modify, store, print) trees and hybridization networks
    graphically.

  + Print trees.

  + Manipulate (edit) character/taxon data.
    - Mask characters and/or taxa.
    - Add/subtract/edit characters and/or taxa.

  + Set various parameters.

  + Monitor program activity:
    - Number of trees in memory.
    - Number of trees evaluated.
    - Various statistics of interest.
    - Current state of algorithm.

  + Interactive command prompt window.

  + Display context-specific documentation.

* Implement ML scoring.

* Implement Bayesian MCMC estimation.

=== Maybe ===

* Write a nexus parser?

* Create a Parser superclass (for NewickParser, FastaParser, NexusParser, etc.)?

* Come up with a better scheme for dealing with machine-specific vector
  optimizations?

* Implement the parsimony ratchet, in order to reproduce Nixon's results.  This
  would be useful when comparing performance of my methods.

* Make it possible to "constrain" nodes (or edges?), whatever that means.  I
  suspect that it means to avoid doing TBR at certain places in the tree.
  Perhaps constraining edges is a better way to go.

EOB
