=== Lewis crossover experiment =================================================

* Add ability to calculate MP scores of multifurcating trees.  This includes
  making the caching machinery work correctly.

* Use CTMatrix to prepare trees for MP.  This will potentially be important,
  since we'll have multiple prepared trees in use at the same time.

* Implement Lewis crossover neighbor calculation for two trees.

  + Validate that trees are compatible (debug mode only?).

  + Make sure both trees are prepared for MP scoring, using the same CTMatrix.

  + For trees in A, B:

    - Iteratively choose all crossover points in tree.

      * Do equivalent of TBR attachment, and score trees.

* Implement tree pool.  Use fitness sharing (as a function of RF-distance) to
  weight fitnesses.

=== Conversion to Python =======================================================

* Move MP code from CxTr.c to CxTreeMp.c.

  Use CTMatrix, rather than copying char data.

* Move tree holding code out of CxTr.c.  It belongs with the MP code (in
  CxTreeMp.c).

* Get rid of CxTr.c entirely.  Move functionality to either be merged with the
  Python glue, or into separate files.

  Add programmatic tree validation, so that it's possible to detect and recover
  from malformed trees.  Right now, the tree validation code is only useful for
  Crux debugging.

* Use tree validation API to make sure that the CxTreeRf.c code doesn't blow up
  on trees with non-contiguous taxon numbers.

* Find out whether it's possible to write a Python class such that methods are
  written in either Python or C.  If this is possible, it would allow me to
  vastly simplify the way new nodes/edges/rings are created.

  The example in 16.5 of _The_Python_Cookbook_ looks like it may provide a
  mechanism for creating classes that have a mutable methods dictionary.  If so,
  it will require quite a bit of code restructuring, but it may be possible to
  merge the C/Python portions of all of crux's classes.

=== General maintenance ========================================================

* Write a nexus parser.

* Uniformly use standard malloc(3) APIs, catch and return errors.  Then, remove
  CxXep and CxMem.

* Remove CxQri, CxQli, and CxQsi, after they are no longer used by the tree
  code.

* It looks like the python code that is used to create tree/node/edge/ring
  objects could be sped up quite a bit.  Right now, it imports, then does a
  lookup of something like crux.Ring.Ring, then calls the constructor.  Instead,
  the constructor could probably be looked up once, then called directly.  The
  node/edge/ring constructors just pass, so they can probably be removed
  completely, which would mean no python code interpretation for node/edge/ring
  object creation.

=== General features ===========================================================

* Add true tree holding, rather than just the limited form of holding that the
  tr code supports.  Collapse unsupported (zero-change) branches when storing
  trees, in order to avoid storing equivalent trees.

  Use heaps or balanced trees to store the best neighbors found so far during a
  TBR/MP run.  Then, at the end, merge those into the main pool of held trees.

* Write tree comparison code that deals with collapsed trees (CxTreeEqual.c)

* Implement Sankoff parsimony, in preparation for supporting protein parsimony.

* Generalize character types to handle protein, as well as arbitrary characters.

* Add code for calculating pairwise distances.  Consider making it MPI-aware
  (Jack seemed to think this would be useful.)

* Implement MSA.  Consider making this general enough to allow heuristic
  simultaneous alignment of an arbitrary number of sequences.

* Implement other heuristic tree constructors, such as sequential addition,
  UPGMA, etc.

* Implement crux.Tree.Tree.dup().

* Implement NNI and SPR.  SPR should be easy, since it is a subset of TBR.

* Implement ML scoring.

=== Research-supporting features ===============================================

* Implement Lewis crossover (in CxTreeCrossover.c).

  + Try iterative hill climbing, where iteration is repeated crossovers between
    the current best tree and another one in hand.

  + Try a hybrid of crossover and TBR hill climbing iteration.  This looks
    promising, unless the hill climbing takes too much time.

  + Try a GA, where crossover is Lewis crossover, and mutation is TBR
    transformation.  I don't have a good feeling for how well this will work.  A
    steady-state population is probably necessary to avoid thrashing around in
    suboptimal tree space.

* Make it possible to allow cyclic graphs (currently constrained to acyclic
  graphs).  This will require adding mark/sweep tree traversal.  If care is
  taken to keep track of whether the mark bits were all restored to the off
  state the last time they were used, it is possible to avoid having to
  iteratively clear the mark bits in advance of traversal.

* Implement the parsimony ratchet, in order to reproduce Nixon's results.  This
  would be useful when comparing performance of my methods.

=== Enhancements to existing features ==========================================

* Do bisection/MP during tree recursion, and get rid of parent pointers/caching.

* Terminate scoring early if identical on a per-word basis.

* Make it possible to permanently discard uninformative characters?  In any
  case, uninformative character elimination is rather opaque at the moment, and
  more information needs to be made available.

* Implement 64-bit version of C-based MP scoring functions, and use it for
  platforms like Mac G5 and x86-64.

* Make MP work for multifurcating trees.

=== Release requirements =======================================================

* Either come up with a simple command line syntax (sorta like PAUP's), or
  provide a number of crux scripts that provide similar ease of use for typical
  operations.

  In order to use Python's argv parser on the script arguments, save sys.argv,
  redefine sys.argv, call the option parser, then restore sys.argv.

* Add interactive help.

* Create rpm for crux.

* Add documentation infrastructure, as well as full documentation of APIs.

=== Long range possibilities ===================================================

* Implement MPI support for certain features.

* Add a GUI.  GUI features:

  + Load/store:
    - NEXUS files.
    - Newick tree files.
    - Phylip distance matrices.
    - FASTA files.
    - Scripts (Python)

  + Manipulate (create, modify, store, print) trees and hybridization networks
    graphically.

  + Print trees.

  + Manipulate (edit) character/taxon data.
    - Mask characters and/or taxa.
    - Add/subtract/edit characters and/or taxa.

  + Set various parameters.

  + Monitor program activity:
    - Number of trees in memory.
    - Number of trees evaluated.
    - Various statistics of interest.
    - Current state of algorithm.

  + Interactive command prompt window.

  + Display context-specific documentation.

* Implement Bayesian MCMC estimation.

=== Maybe ======================================================================

* Come up with a better scheme for dealing with machine-specific vector
  optimizations?

* Make it possible to "constrain" nodes (or edges?), whatever that means.  I
  suspect that it means to avoid doing TBR at certain places in the tree.
  Perhaps constraining edges is a better way to go.

EOB
