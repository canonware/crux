* Write a nexus parser.

=== Conversion to Python =======================================================

* Move MP code from CxTr.c to CxTreeMp.c.

* Move tree holding code out of CxTr.c.  It belongs with the MP code (in
  CxTreeMp.c).

* Get rid of CxTr.c entirely.  Move functionality to either be merged with the
  Python glue, or into separate files.

  Add programmatic tree validation, so that it's possible to detect and recover
  from malformed trees.  Right now, the tree validation code is only useful for
  Crux debugging.

* Use tree validation API to make sure that the CxTreeRf.c code doesn't blow up
  on trees with non-contiguous taxon numbers.

=== General maintenance ========================================================

* Uniformly use standard malloc(3) APIs, catch and return errors.  Then, remove
  CxXep and CxMem.

* Remove CxQri, CxQli, and CxQsi, after they are no longer used by the tree
  code.

* It looks like the python code that is used to create tree/node/edge/ring
  objects could be sped up quite a bit.  Right now, it imports, then does a
  lookup of something like crux.Ring.Ring, then calls the constructor.  Instead,
  the constructor could probably be looked up once, then called directly.  The
  node/edge/ring constructors just pass, so they can probably be removed
  completely, which would mean no python code interpretation for node/edge/ring
  object creation.

=== General features ===========================================================

* Add true tree holding, rather than just the limited form of holding that the
  tr code supports.  Collapse unsupported (zero-change) branches when storing
  trees, in order to avoid storing equivalent trees.

* Write tree comparison code that deals with collapsed trees (CxTreeEqual.c)

* Implement Sankoff parsimony, in preparation for supporting protein parsimony.

* Generalize character types to handle protein, as well as arbitrary characters.

* Add code for calculating pairwise distances.  Consider making it MPI-aware
  (Jack seemed to think this would be useful.)

* Implement MSA.  Consider making this general enough to allow heuristic
  simultaneous alignment of an arbitrary number of sequences.

* Implement other heuristic tree constructors, such as sequential addition,
  UPGMA, etc.

* Implement crux.Tree.Tree.dup().

* Implement NNI and SPR.  These should be easy, since they are subsets of TBR.

* Implement ML scoring.

=== Research-supporting features ===============================================

* Implement Lewis crossover (in CxTreeCrossover.c).

  + Try iterative hill climbing, where iteration is repeated crossovers between
    the current best tree and another one in hand.

  + Try a hybrid of crossover and TBR hill climbing iteration.  This looks
    promising, unless the hill climbing takes too much time.

  + Try a GA, where crossover is Lewis crossover, and mutation is TBR
    transformation.  I don't have a good feeling for how well this will work.  A
    steady-state population is probably necessary to avoid thrashing around in
    suboptimal tree space.

* Make it possible to allow cyclic graphs (currently constrained to acyclic
  graphs).  This will require adding mark/sweep tree traversal.  If care is
  taken to keep track of whether the mark bits were all restored to the off
  state the last time they were used, it is possible to avoid having to
  iteratively clear the mark bits in advance of traversal.

* Implement the parsimony ratchet, in order to reproduce Nixon's results.  This
  would be useful when comparing performance of my methods.

=== Enhancements to existing features ==========================================

* Do bisection/MP during tree recursion.

* Terminate scoring early if identical on a per-word basis.

* Make it possible to permanently discard uninformative characters?  In any
  case, uninformative character elimination is rather opaque at the moment, and
  more information needs to be made available.

=== Release requirements =======================================================

* Either come up with a simple command line syntax (sorta like PAUP's), or
  provide a number of crux scripts that provide similar ease of use for typical
  operations.

  In order to use Python's argv parser on the script arguments, save sys.argv,
  redefine sys.argv, call the option parser, then restore sys.argv.

* Add interactive help.

* Create rpm for crux.

* Add documentation infrastructure, as well as full documentation of APIs.

=== Long range possibilities ===================================================

* Implement MPI support for certain features.

* Add a GUI.  GUI features:

  + Load/store:
    - NEXUS files.
    - Newick tree files.
    - Phylip distance matrices.
    - FASTA files.
    - Scripts (Python)

  + Manipulate (create, modify, store, print) trees and hybridization networks
    graphically.

  + Print trees.

  + Manipulate (edit) character/taxon data.
    - Mask characters and/or taxa.
    - Add/subtract/edit characters and/or taxa.

  + Set various parameters.

  + Monitor program activity:
    - Number of trees in memory.
    - Number of trees evaluated.
    - Various statistics of interest.
    - Current state of algorithm.

  + Interactive command prompt window.

  + Display context-specific documentation.

* Implement Bayesian MCMC estimation.

=== Maybe ======================================================================

* Come up with a better scheme for dealing with machine-specific vector
  optimizations?

* Make it possible to "constrain" nodes (or edges?), whatever that means.  I
  suspect that it means to avoid doing TBR at certain places in the tree.
  Perhaps constraining edges is a better way to go.

EOB
