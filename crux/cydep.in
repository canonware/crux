#!@PYTHON@@python_opts@
#
# Find .pxd/.py/.h dependencies for a .pyx/.pxd via minimalistic parsing.

import optparse
import os
import re
import sys

class CydepHelpFormatter(optparse.IndentedHelpFormatter):
    def format_usage(self, usage):
        return """cydep usage:
    cydep -h | --help
    cydep [<options>]

    Option               | Description
    ---------------------+-----------------------------------------------
    -h | --help          | Print usage and exit.
    -I <dir>             | Add <dir> to C include path.
    -P <dir>             | Add <dir> to Python module path.
    --infile=<file>      | Find dependencies for <file>.
    --outfile=<file>     | Write dependencies to <file>.

cydep generates non-transitive dependencies (no recursion).  Process
each source file individually whenever it is modified, and provide all
the dependencies to 'make'.
"""

# Process the command line.
def parse_options():
    helpformatter = CydepHelpFormatter()
    parser = optparse.OptionParser(formatter=helpformatter, add_help_option=0)
    parser.disable_interspersed_args()
    parser.add_option("-h", "--help", dest="help", action="store_true",
      default=False)
    parser.add_option("-I", dest="ipath", action="append", default=[])
    parser.add_option("-P", dest="ppath", action="append", default=[])
    parser.add_option("--infile", dest="infile", default=None)
    parser.add_option("--outfile", dest="outfile", default=None)

    (opts, rem) = parser.parse_args()
    if len(rem) > 0:
        print >> sys.stderr, "cydep: Invalid argument%s: %r" % \
          (("" if len(rem) == 1 else "s"), rem)
        CydepHelpFormatter().format_usage("")
        sys.exit(1)

    if opts.help:
        print helpformatter.format_usage("")
        sys.exit(0)

    return opts

def resolve_import(import_, indir, ppath, templates):
    relative = False

    elms = import_.split(".")
    if elms[0] == "":
        # Explicit relative import.
        relative = True
        elms.pop(0)
        for i in xrange(len(elms)):
            if elms[i] != "":
                break
            elms[i] = ".."

    # Try relative import.
    for template in templates:
        path = template % ("/".join([indir] + elms))
        if os.path.exists(path):
            return path

    if relative:
        print >> sys.stderr, "Unresolvable relative import: %r" % i
        sys.exit(1)

    # Search ppath for the module.
    for p in opts.ppath:
        for template in templates:
            path = template % ("/".join([p] + elms))
            if os.path.exists(path):
                return path

    return None

#
# Beginning of main execution.
#

# Parse command line options.
opts = parse_options()

if opts.infile is not None:
    infile = open(opts.infile, 'r')
    indir = os.path.dirname(opts.infile)
else:
    opts.infile = "<stdin>"
    infile = sys.stdin
    indir = "."
lines = infile.readlines()

# Pre-process input to combine lines with multi-line statements/strings.
reCont = re.compile(r"^(.*)\\$")
i = 0
while i < len(lines):
    # Merge multi-line """...""" strings.
    while len(lines[i].split('"""')) % 2 == 0:
        lines[i] = lines[i] + lines[i+1]
        lines.pop(i+1)

    # Merge multi-line '''...''' strings.
    while len(lines[i].split("'''")) % 2 == 0:
        lines[i] = lines[i] + lines[i+1]
        lines.pop(i+1)

    # Merge \-continued lines.
    m = reCont.match(lines[i])
    if m:
        lines[i] = m.group(1) + lines[i+1]
        lines.pop(i+1)
    else:
        i += 1

#
# Look for statements that induce file dependencies.
#
includes = set()
cimports = set()
imports = set()
for line in lines:
    # cdef extern from "spam.h":
    m = re.compile(r'^\s*cdef\s+extern\s+from\s+"([^"]*)"\s*:').match(line)
    if m:
        includes.add(m.group(1))
        continue

    # cimport .Spam
    # cimport Spam
    # cimport Spam.Ham
    # cimport Spam, Ham
    m = re.compile(r"^\s*cimport\s+([A-Za-z_.][A-Za-z0-9_.]*)(.*)$").match(line)
    if m:
        cimports.add(m.group(1))
        rem = m.group(2)
        m = re.compile(r"\s*,\s*([A-Za-z_.][A-Za-z0-9_.]*)(.*)$").match(rem)
        while m:
            cimports.add(m.group(1))
            rem = m.group(2)
            m = re.compile(r"\s*,\s*([A-Za-z_.][A-Za-z0-9_.]*)(.*)$").\
              match(rem)
        continue

    # from Spam cimport <...>
    m = re.compile(r"^\s*from\s+([A-Za-z_.][A-Za-z0-9_.]*)\s+cimport\s").\
      match(line)
    if m:
        cimports.add(m.group(1))
        continue

    # import .Spam
    # import Spam
    # import Spam.Ham
    # import Spam, Ham
    m = re.compile(r"^\s*import\s+([A-Za-z_.][A-Za-z0-9_.]*)(.*)$").match(line)
    if m:
        imports.add(m.group(1))
        rem = m.group(2)
        m = re.compile(r"\s*,\s*([A-Za-z_.][A-Za-z0-9_.]*)(.*)$").match(rem)
        while m:
            imports.add(m.group(1))
            rem = m.group(2)
            m = re.compile(r"\s*,\s*([A-Za-z_.][A-Za-z0-9_.]*)(.*)$").\
              match(rem)
        continue
    # from ..Spam import <...>
    m = re.compile(r"^\s*from\s+([A-Za-z_.][A-Za-z0-9_.]*)\s+import\s").\
      match(line)
    if m:
        imports.add(m.group(1))
        continue

# Prepare outfile.
if opts.outfile is not None:
    try:
        os.makedirs(os.path.dirname(opts.outfile))
    except os.error:
        pass
    outfile = open(opts.outfile, "w+")
else:
    outfile = sys.stdout
    opts.outfile = "<stdout>"

deps = set()

# Resolve #include dependencies.
for i in includes:
    for p in opts.ipath:
        path = "%s/%s" % (p, i)
        if os.path.exists(path):
            deps.add(path)
            break
    else:
        print >> sys.stderr, "Unresolvable #include: %r" % i
        sys.exit(1)

# Resolve cimport dependencies.
for i in cimports:
    path = resolve_import(i, indir, opts.ppath, ("%s.pxd", "%s/__init__.pxd"))
    if path is not None:
        deps.add(path)
    else:
        outfile.write("# Unresolvable: cimport %s\n" % i)

# Resolve import dependencies.
for i in imports:
    path = resolve_import(i, indir, opts.ppath, ("%s.py", "%s/__init__.py"))
    if path is not None:
        deps.add(path)
    else:
        outfile.write("# Unresolvable: import %s\n" % i)

# Write out dependencies.
instem = opts.infile.split(".")[-2]
outfile.write("%s.c :" % instem)
outfile.write(" \\\n  %s.pyx" % instem)
if os.path.exists("%s.pxd" % instem):
    outfile.write(" \\\n  %s.pxd" % instem)
deps = list(deps)
deps.sort()
for dep in deps:
    outfile.write(" \\\n  %s" % dep)
outfile.write("\n")
outfile.close()
